# 基礎理論
## コンピュータの世界
ビット　・・・　１か０が入る一つの箱

バイト　・・・　８個ビットが集まると、１バイトになる
```
8bit = 1byte
```
## 2進数
10進数 = 箱の大きさが9 = 使う数字が１０個

n進数 = 箱の大きさがn-1 = 使う数字がn個

2進数の場合、桁が繰り上がるたびに、箱の大きさが2倍の数になっていく。

```
123（１０進数） → 1111011（２進数）
```
123（１０進数）を2進数に変換する場合
```
123 / 2 = 61 あまり 1
61 / 2 = 30 あまり 1
30 / 2 = 15 あまり 0
15 / 2 = 7 あまり 1
7 / 2 = 3 あまり 1
3 / 2 = 1 あまり 1
で、最後の商の1から、あまりを遡ったものが答えとなる
#=> 1111011
```

1011（2進数）を10進数に変換する場合
```
1      0      1      1 
8の桁   4の桁   2の桁   1の桁
8 + 2 + 1
#=> 11
```

## 論理演算
```
２進数の足し算に必要な最も基本の演算
0 + 0 = 0
0 + 1 = 1
1 + 0 = 1
1 + 1 = 10

論理演算（0と1の組み合わせで計算をすること）

・AND（論理積）
　どちらも１のとき、１を出力する
・OR（論理和）
 どちらかが１のとき、１を出力する
・NOT（否定）
 ０と１を反転する
 
この３つの基本回路があれば、出力と入力の組み合わせを自在に作り出すことができる

・NAND（否定論理積）
 どちらも１のとき、０を出力する
・NOR(否定論理和) 
 どちらかが１のとき、０を出力する
・XOR（排他的論理和）
 どちらかが１のときのみ、１を出力する

真理値表（XOR）
A B 出力
0 0 0
0 1 1
1 0 1
1 1 0
#=> XORの出力結果と、2進数の最も基本の演算の結果が一致する
```

## 2進数の計算
```
・足し算
    1111011
  + 1111111
#=>11111010 = 250（10進数）

・引き算
コンピュータは足し算しかできないので、引き算を足し算で表す
うまくいくように負の数を表す = 補数表現

例）10進数の補数で引き算してみると
127 - 123 = 4
↓
127 + 877（123の10の補数） = 1004（004）
n進数の引き算は、nの補数を使えば、足し算で表せる
※nの補数とは、桁が繰り上がりするのに、必要な数のこと。

【2進数の場合】
1111011
繰り上がりしない最大値は、100
つまり、101を足せば、繰り上がる。 101 = 1111011の2の補数

1111111 - 1111011 = 100
↓
1111111 + 101 = 10000100(0000100)
※2進数の引き算は、2の補数を足す！

2の補数の作り方
111001
↓　すべてのビットを反転させる
000110（1の補数）
↓　1を足す
000111（2の補数）

・シフト演算（掛け算/割り算）
掛け算（論理シフト）
   00001101    （13）
 ↓ 2n倍したい     ↓ 2×2 = 4倍  
 0000110100    （52）
#=> ｎだけ左にずらす

割り算（論理シフト）
   00001101    （13）
 ↓ 1/2n倍したい   ↓ 1/2×2 = 1/4倍
   0000001101  （3） 
#=> nだけ右にずらす
右端にはみ出た01が余りとなる。
```

# ハードウェア


# ソフトウェア

# データベース

# ネットワーク

# セキュリティ

# プログラム
