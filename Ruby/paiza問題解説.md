# 新・Bランクレベルアップメニュー

【マップの扱い 2】マップの書き換え・縦横

```ruby
h, w = gets.chomp.split.map(&:to_i)
move = [-1, 1]
str = []

h.times do
  str << gets.chomp
end

y, x = gets.chomp.split.map(&:to_i)

if str[y][x] == "."
  str[y][x] = "#"
else
  str[y][x] = "."
end

move.each do |i|
  if 0 <= y + i && y + i < h
    if str[y + i][x] == "."
      str[y + i][x] = "#"
    else
      str[y + i][x] = "."
    end
  end

  if 0 <= x + i && x + i < w
    if str[y][x + i] == "."
      str[y][x + i] = "#"
    else
      str[y][x + i] = "."
    end
  end
end

str.each do |s|
  puts s
end

# このコードは、与えられた盤面に対して、指定された座標とその周囲のマスを反転させる処理を行い、変更後の盤面を出力するプログラムです。
# 最初の行では、盤面の高さを表す整数 h と、盤面の幅を表す整数 w を入力しています。
# getsメソッドで標準入力から取得した文字列を、splitメソッドで空白で区切って配列に分割し、mapメソッドで各要素を整数に変換して、それぞれ h と w に代入しています。
# 次に、移動する量を表す配列 move を定義し、空の配列 str を初期化しています。
# その後、 h 回ループを回しながら、getsメソッドで標準入力から取得した文字列を配列 str に格納しています。
# 次に、指定された座標を表す変数 y と x を、getsメソッドで標準入力から取得しています。
# その後、座標(y, x)のマスの状態によって、マスを反転させています。座標(y, x)のマスの状態が"."であれば、"#"に変更し、"#"であれば"."に変更します。
# 最後に、移動量を表す配列 move の要素を順番に取り出しながら、指定された座標から上下左右のマスを順番に反転させています。
# まず、座標(y + move[i], x)が盤面内に存在するかどうかをチェックし、存在する場合はそのマスの状態を反転させます。
# 次に、座標(y, x + move[i])が盤面内に存在するかどうかをチェックし、存在する場合はそのマスの状態を反転させます。
# 最後に、配列 str の要素を順番に取り出しながら、各行を改行付きで出力しています。
```

【文字列 1】疑似数字 
```ruby
s = gets.chomp

 # 0以上 s.length未満
(0...s.length).each do |i|
  (i...s.length).each do |j|
    if s[i].match?(/\d/) && s[j].match?(/\d/)
      puts s[i..j]
    end
  end
end

# このコードは、入力された文字列 s 中の数字の部分文字列を見つけて、それを出力するプログラムです。
# まず、 gets.chomp メソッドを使って、標準入力から文字列を受け取ります。受け取った文字列は、変数 s に格納されます。
# 次に、2重の each ループを使って、文字列中のすべての部分文字列の組み合わせを網羅します。
# i と j は、それぞれ部分文字列の最初の文字と最後の文字のインデックスを表します。 
# i のループ範囲は 0 から s.length - 1 までで、 j のループ範囲は i から s.length - 1 までです。
# 各部分文字列に対して、 if ステートメントを使って、文字列中の i 番目と j 番目の文字がどちらも数字である場合にのみ、その部分文字列を出力します。
# 数字であるかどうかを判断するには、 match? メソッドを使って正規表現 \d （数字）にマッチするかどうかを確認します。
# 最後に、 puts メソッドを使用して、数字の部分文字列を出力します。
# 部分文字列を取得するには、 [] メソッドによって文字列をスライスして、範囲演算子 .. を使用して、部分文字列を指定します。
# このコードでは、範囲演算子 ... を使用して、最初の値から最後の値を含まない範囲を指定することで、部分文字列の組み合わせを網羅しています。
# また、Rubyの場合、文字列の最初の文字を取得するには、0 を使う代わりに、[0] を使用することができます。

二重のeachループについて
# 外側のループが i=0 で始まり、内側のループが j=0 で始まる。
# j が増えるにつれて、s[i..j] が部分文字列になる。
# 内側のループが終了すると、外側のループが i=1 で再び始まり、内側のループが j=1 で始まる。
# これが最後の組み合わせになるまで、i と j の値を増やし続ける。

```

【条件判定 3】過剰コンプライアンス
```ruby
n = gets.chomp.to_i
ban = gets.chomp

n.times do
  str = gets.chomp

  if str.size == ban.size
    if str == ban
      puts "banned"
    elsif str[0...(str.size+1)/2] == ban[0...(str.size+1)/2]
      x = "x" * ((str.size+1)/2)
      puts x + str[(str.size+1)/2...str.size]
    elsif str[str.size/2...str.size] == ban[str.size/2...str.size]
      x = "x" * ((str.size+1)/2)
      puts str[0...str.size/2] + x
    else
      puts str
    end
  else
    puts str
  end
end

# このコードは、最初に整数 n と文字列 ban を読み込み、その後に n回ループを実行し、各ループで文字列 str を読み込んで処理を行うものです。
# 具体的には、各ループでは、str の長さが ban の長さと等しい場合には、以下の処理を行います。
# str が ban と等しい場合には、"banned" と出力します。
# str の前半部分が ban の前半部分と一致する場合には、str の前半部分に "x" をつなげ、str の後半部分をそのままつなげた文字列を出力します。
# str の後半部分が ban の後半部分と一致する場合には、str の前半部分をそのままつなげ、str の後半部分に "x" をつなげた文字列を出力します。
# 上記以外の場合には、str をそのまま出力します。
# str の長さが ban と等しくない場合には、str をそのまま出力します。
# 具体的な処理は、文字列のスライスを利用して行われています。
# 例えば、str[0...(str.size+1)/2] は、str の先頭から (str.size+1)/2 文字目までの部分文字列を取得することを意味します。
# また、"x" を繰り返しつなげる場合には、"x" * ((str.size+1)/2) のように、* 演算子を使って簡単に表現できます。
```

【全探索 1】高い寿司を食いたい！

```ruby
num, eat = gets.chomp.split.map(&:to_i)
price = []

num.times do |i|
    price << gets.chomp.to_i
end

eat_price = 0

(0...num).each do |i|
  sum = 0
  (0...eat).each do |j|
    sum += price[(i + j) % num]
  end
  
  # eat_price と sum の大きい方を eat_price に代入
  eat_price = [eat_price, sum].max
end

puts eat_price

# このコードは、与えられた数列から、連続した部分列の中で要素の和が最大になるものを見つけて、それを出力するプログラムです。
# 最初に、 gets.chomp.split.map(&:to_i)を使って、標準入力から2つの整数を読み込み、それぞれ num と eat に代入しています。
# num は数列の要素数を表し、eat は求める連続した部分列の長さを表します。
# 次に、配列 price を初期化し、num 回繰り返しを行います。
# 各繰り返しでは、 gets.chomp.to_iを使って標準入力から整数を読み込み、配列 price に追加しています。
# このようにして、与えられた数列が price 配列に格納されます。
# 次に、eat_price を初期化し、2重の繰り返しを行います。外側の繰り返しでは、num 回繰り返しを行い、内側の繰り返しでは、eat 回繰り返しを行います。
# 内側の繰り返しでは、現在の位置から eat 個先の要素を順に加算して sum に格納します。
# 内側の繰り返しが終了したら、eat_price と sum の大きい方を eat_price に代入します。
# 最後に、eat_price を出力します。これは、与えられた数列から求めた連続した部分列の中で、要素の和が最大になるものです。
```

【シミュレーション 2】perfuct shuffle
```ruby
k = gets.to_i
deck = []
upper_side = []
lower_side = []
mark = ["S", "H", "D", "C"]

mark.each do |m|
  (1..13).each do |n|
    deck.push(m + "_" + n.to_s)
  end
end

k.times do
  upper_side = deck[0..25]
  lower_side = deck[26..51]
  deck.each_with_index do |_val, i|
    if i % 2 == 0
      deck[i] = upper_side[i / 2]
    else
      deck[i] = lower_side[i / 2]
    end
  end
end

puts deck

# このコードは、トランプのカードをシャッフルする処理を行うものです。
# 最初に、gets.to_iを使って、トランプをシャッフルするための繰り返し回数を読み込み、 k に代入します。
# 次に、 deck という配列を定義し、mark の各スートと、各スートの1から13までの数字を組み合わせて作られる、52枚のカードを順に push していきます。
# その後、トランプをシャッフルするために、 upper_side と lower_side という配列を定義し、deck の上半分と下半分にそれぞれ格納します。
# そして、 deck の要素を順番に走査し、偶数番目の要素は upper_side の要素を、奇数番目の要素は lower_side の要素を挿入します。
# この処理で、トランプをシャッフルしていることになります。
# 最後に、 deck を出力することで、シャッフルされたトランプのカードが表示されます。
```

【計算 1】マンハッタン距離
```ruby
px, py = gets.split.map(&:to_i)
n = gets.to_i

euclid_len = []
manhattan_len = []

n.times do |i|
  x, y = gets.split.map(&:to_i)
  
  # **は累乗（同じ数をくり返しかけ算する）
  euclid_len << [(px - x) ** 2 + (py - y) ** 2, i + 1]
  manhattan_len << [(px - x).abs + (py - y).abs, i + 1]
end

euclid_len.sort!
manhattan_len.sort!

3.times do |i|
  puts euclid_len[i][1]
end

3.times do |i|
  puts manhattan_len[i][1]
end

# このコードは、点 (px, py) と複数の点 (x, y) の間の距離を計算して、それらの距離に基づいて最も近い3つの点のインデックスを出力するプログラムです。
# 具体的には、以下の手順に従っています。
# 入力された px と py の値を取得し、整数に変換して変数に代入します。
# 入力された点の数 n の値を取得し、整数に変換して変数に代入します。
# euclid_len と manhattan_len という2つの空の配列を作成します。
# これらの配列に、各点 (x, y) と点 (px, py) とのユークリッド距離とマンハッタン距離を計算した結果を、距離の値とその点のインデックス (i + 1) とのペアの形式で追加していきます。
# euclid_len と taxi_len を距離の値に基づいてソートします。
# 最も近い3つの距離に対応するインデックスを出力します。
```

【条件判定 1】郵便料金
```ruby
y, x, h = gets.split.map &:to_i
l = gets.split.map &:to_i
m = gets.split.map &:to_i

if h <= l[0]
  if [y, x].max <= l[1]
    puts m[0]
  elsif y + x <= l[2]
    puts m[1]
  else
    puts m[2]
  end
else
  if [y, x, h].max <= l[3]
    puts m[3]
  elsif y + x + h <= l[4]
    puts m[4]
  else
    puts (y * x * h) * m[5]
  end
end

# このコードは、3つの変数 y, x, h に、縦・横・高さを割り当て、2つの配列 l, m に、長さ・料金を割り当て、問題の条件に従って郵便料金を出力するプログラムです。
# 最初の行で、 gets.split.map &:to_i を使用して、標準入力からスペース区切りで複数の整数を一度に取得し、 to_i メソッドを適用して、それらを整数に変換しています。
# 次の行で、同じく gets.split.map &:to_i を使用して、配列 l を取得しています。配列 m も同じ方法で取得しています。
# 郵便料金の判定は、まず、h <= l[0]の長さかどうかで、条件分岐し、その中で、さらに条件分岐をする二重のif文になっています。
# if [y, x].max <= l[1] で、「縦と横の長い方の長さが l[1] 以下の場合」、という条件を表しています。
# if [y, x, h].max <= l[3] は、それに高さを加えて、l[3]以下の場合かどうかを判定します。
```

【配列 1】平面で計算
```ruby
n = gets.chomp.to_i
a = Array.new(n) { Array.new(n, 0) }

n.times do |i|
  a[i] = gets.chomp.split.map(&:to_i)
end

ans = 0

n.times do |i|
  row_sum = 0
  col_sum = 0

  n.times do |j|
    row_sum += a[i][j]
    col_sum += a[j][i]
  end

  ans = [row_sum, col_sum, ans].max
end

left_right_down = 0
left_right_up = 0

n.times do |i|
  left_right_down += a[i][i]
  left_right_up += a[n - 1 - i][i]
end

ans = [left_right_down, left_right_up, ans].max

puts ans

# このコードは、与えられた N × N の行列を読み取り、行、列、斜め方向の和を計算し、それらの中の最大値を出力するものです。
# 最初の3行は、N を読み取り、a という名前の N × N の2次元配列を作成します。ここで、Array.new 関数は、多次元配列を作成するために使用されます。各要素は 0 で初期化されます。
# 次のループは、標準入力から N 行の整数を読み取り、それらを配列 a の各行に割り当てます。
# ここでは、getsメソッドを使用して行を読み取り、chompメソッドを使用して末尾の改行文字を取り除き、splitメソッドを使用して行をスペースで区切り、各数字を整数に変換します。
# 次のループは、ansという変数を初期化し、配列aの各行、列の和を同時に計算し、それらの最大値を、maxメソッドで ans に割り当てます。
# そして、２つの斜め方向（左上から右下、右上から左下）の和を計算するため、left_right_down, left_right_up の変数を用意します。
# ここでのループで、２つの斜め方向の和を同時に計算し、それらの最大値をansに割り当てます。
# 右上から左下の和は、 left_right_up += a[n - 1 - i][i]　で、 i をマイナスしていくことで求めます。
# 最後に、ansを出力します。
```

# データセット選択メニュー
数値の出現率
```ruby
n = gets.to_i
lines = gets.split.map(&:to_i)
time = []

(0..9).each do |i|
  num = 0
  lines.each do |j|
    if j == i
     num += 1 
    end
  end
  time << num
end

puts time.join(" ")

# このコードは、Rubyで書かれたプログラムで、標準入力から整数 n と n 個の整数がスペース区切りで与えられると、
  0から9までの数字それぞれが出現した回数をカウントし、その結果をスペース区切りで出力するものです。
# まず、整数 n と n 個の整数を取得し、それらを配列 lines に格納しています。
# 次に、0から9までの数字それぞれに対して、lines をイテレートし、その数字が出現した回数をカウントします。
# 具体的には、 num 変数を 0 で初期化し、lines をイテレートし、各数字が i と等しい場合に num を 1 増やします。
# その後、time 配列に num を追加します。
# 最後に、time をスペース区切りで出力します。ここでは、joinメソッドを使用して、 time の各要素を文字列に変換し、
  スペースで区切った文字列を生成。putsを使用して、この文字列を出力しています。
```

英小文字の出現率
```ruby
nums = Array.new(26, 0)

n = gets.to_i
str = gets.chomp
str.each_char do |c|
    nums[c.ord - 'a'.ord] += 1
end

puts nums.join(' ')

# このコードは、与えられた文字列 str 中の各文字の出現回数をカウントし、その結果を出力するものです。以下、コードの詳細を解説します。
# まず、nums という名前の長さ 26 の配列を作成します。各要素は初期値 0 で初期化されます。
# 次に、入力値を受け取ります。gets.to_iは標準入力から1行読み込んで、整数に変換します。
# gets.chompは標準入力から1行読み込んで、末尾の改行文字を取り除いた文字列を返します。
# each_charメソッドは、文字列 str を1文字ずつ取り出して、ブロック内の処理を繰り返します。
# ブロック内では、各文字の出現回数を nums 配列に加算します。ここで、c.ordは文字 c のUnicodeコードポイントを返します。
# 'a'.ordは文字 a のUnicodeコードポイントを返します。したがって、c.ord - 'a'.ordは文字 c のアルファベットインデックスを表します。
# 例えば、c が'b'であれば、c.ord - 'a'.ordは 1 となります。
# 最後に、nums 配列の各要素をスペース区切りの文字列に変換して、標準出力に出力します。
# joinメソッドは、配列の要素を指定された文字列で連結して、1つの文字列に変換します。ここでは、スペース文字を区切り文字として指定しています。
# 最後に、putsメソッドで文字列を出力します。
```

文字列の出現率
```ruby
str = {}

n = gets.to_i
n.times do
  t = gets.chomp
  str[t] ||= 0
  str[t] += 1
end

str = str.sort

str.each do |key, value|
  puts "#{key} #{value}"
end

# このコードは、ユーザーからの入力に基づいて文字列の出現回数をカウントし、結果をアルファベット順で表示するものです。
# 具体的には、以下のような手順で実行されます。
# 空のハッシュ str を定義します。
# ユーザーからの入力を受け取り、その数を n に代入します。
# n 回、以下の手順を繰り返します。
#  a. ユーザーからの入力を受け取り、t に代入します。
#  b. str ハッシュのキー t が偽（nil か false）もしくは未定義の場合、str[t] に 0 を代入します。
#  c. str[t] の値に 1 を加えます。
# str ハッシュをキーでソートします。
# ソートされた str ハッシュの各要素について、以下の手順を繰り返します。
#  a. キーを key、値を value に代入します。
#  b. "#{key} #{value}" を出力します。
```

価格の算出
```ruby
goods = {}

n, m = gets.chomp.split.map(&:to_i)
n.times do
  a, b = gets.chomp.split
  goods[a] = b.to_i
end

m.times do
  s = gets.chomp
  if goods.key?(s)
    # 商品がある場合
    puts goods[s]
  else
    # 商品がない場合
    puts "-1"
  end
end

# このコードは、商品の名前と価格をハッシュで管理し、与えられた商品名に対応する価格を出力するプログラムです。
# まず、最初に入力された2つの整数 n と m を取得します。 n は商品の数を表し、 m は問い合わせの数を表します。
# 次に、n 回のループを行い、各商品の名前 a と価格 b をハッシュに保存します。
# そして、 m 回のループを行い、各問い合わせに対してハッシュ内での存在チェックを行います。
# もし商品名がハッシュ内に存在する場合、その商品の価格を出力します。存在しない場合は-1を出力します。
```

商品の検索
```ruby
str = {}
N, Q = gets.split.map(&:to_i)
(1..N).each do |i|
  s = gets.chomp
  if str[s].nil?
    # sが初めて出てきた場合
    str[s] = i
  end
end

(1..Q).each do
  t = gets.chomp
  if str.key?(t)
    # sのなかにtがある場合
    puts str[t]
  else
    # sのなかにtがない場合
    puts -1
  end
end

# このコードは、与えられた文字列 str に対して、 Q 個のクエリを処理し、各クエリで与えられた文字列 t が str に存在する場合、
  そのインデックスを出力し、存在しない場合は -1 を出力するものです。
# まず、 str という空のハッシュを作成します。 gets メソッドを使って入力を受け取り、空白で区切られた2つの整数 N と Q を配列として読み込みます。
# 次に、 N 行の入力を受け取り、それぞれの入力を s に格納し、 s が str 内にない場合、 s をキーとして、 s が初めて出現する位置を値として str に格納します。
# 最後に、 Q 個のクエリを受け取り、各クエリで与えられた文字列 t が str 内にあるかどうかを調べます。 str 内にある場合、対応する値を出力し、存在しない場合は -1 を出力します。
```

# 配列メニュー
i番目の出力 2 
```ruby
K,L = gets.split.map &:to_i
arr= Array.new(3) {Array.new(3)}

(0...3).each do |i|
    line = gets.chomp.split.map(&:to_i)
    (0...3).each do |j|
        arr[i][j] = line[j]
    end
end

puts arr[K - 1][L - 1]

# このコードは、ユーザーからの入力を処理し、2次元配列から要素を取り出して出力するものです。
# 最初の行では、ユーザーから2つの整数値を取得し、それらを K と L に割り当てます。
# 次に、3x3の nil行列 arr を作成します。これは、後で要素を置き換えるための土台として使用されます。
# 3回のループを使用して、3つの行のそれぞれについて、ユーザーから3つの整数値を取得します。
# その後、各整数値を、arr の対応する位置にある要素に変換し、 arr を更新します。
# 最後に、arr[K-1][L-1]を出力します。これは、K行L列の要素にアクセスするために、K-1行、L-1列のインデックスが使用されるためです。
# つまり、ユーザーによって入力された行番号と列番号は、0から始まる配列のインデックスに変換されます。
```

【二次元配列の入出力】i番目の出力 Boss
```ruby
N,M,K,L = gets.split.map &:to_i

arr= Array.new(N) {Array.new(M)}

(0...N).each do |i|
    line = gets.chomp.split.map(&:to_i)
    (0...M).each do |j|
        arr[i][j] = line[j]
    end
end

puts arr[K - 1][L - 1]

# このコードは、標準入力から N 行 M 列の行列を読み取り、行列内の要素を2次元配列 arr に格納し、 K 行 L 列の要素を出力するものです。
# 最初の行では、標準入力からスペースで区切られた整数値N、M、K、Lを取得しています。
# これらの値は、それぞれ行列の行数、列数、出力する要素の行インデックス、列インデックスを表しています。
# 次の行では、Array.newメソッドを使用して、N 行 M 列の2次元配列 arr を作成しています。この2次元配列には、行列内の要素が格納されます。
# その後、(0...N).eachを使用して、行列内の要素を1つずつ読み取り、2次元配列 arr に格納しています。
# 具体的には、gets.chomp.split.map(&:to_i)を使用して、スペースで区切られた整数値を読み取り、arr[i][j]に格納しています。
# これにより、行列内の各要素が2次元配列 arr の対応する位置に保存されます。
# 最後に、puts arr[K - 1][L - 1]を使用して、K行L列の要素を出力しています。
# 注意点として、行列のインデックスは1から始まるため、K と L から1を引いて、2次元配列 arr の対応するインデックスに変換しています。
```

二点間の距離 1
```ruby
n = gets.chomp.to_i

x = []
y = []
n.times do
  xi, yi = gets.chomp.split.map(&:to_i)
  x << xi
  y << yi
end

n.times do |i|
  puts (x[i] - 2).abs + (y[i] - 3).abs
end

# このコードは、ユーザーから n 個の座標のペアを受け取り、それぞれの座標が点(2, 3)からのマンハッタン距離を計算して出力するものです。
# 具体的には、最初にgets.chomp.to_iを使用して n を受け取ります。
# 次に、n 回の繰り返しを行い、gets.chomp.split.map(&:to_i)を使用して、ユーザーからの入力を座標のペアとして受け取り、
  x と y という2つの配列に座標を格納します。
# 最後に、n 回の繰り返しを行い、それぞれの座標のマンハッタン距離を計算して、出力します。
# 具体的には、x[i]と 2 の差の絶対値と、y[i]と 3 の差の絶対値をそれぞれ計算し、足し合わせた結果を出力します。
```

フィボナッチ数
```ruby
n = gets.to_i

f = Array.new(n)
f[0] = 0
f[1] = 1

(2...n).each do |i|
  # フィボナッチ数列を計算
  f[i] = f[i-1] + f[i-2]
end

f.each do |num|
  puts num
end

# このコードは、フィボナッチ数列の最初の n 項を計算して出力するRubyプログラムです。
# 最初の行では、ユーザーから整数値 n を入力し、その値をgets.to_iで取得しています。
# 次に、配列 f を宣言しています。Array.new(n)は、n 個の要素を持つ配列を作成します。
# その後、最初の2つの要素を 0 と 1 に設定します。これらの要素は、フィボナッチ数列の最初の2つの項を表します。
# そして、2 から n-1 までの範囲をループ処理し、各要素をフィボナッチ数列の項で埋めます。
# ループ内では、f[i] = f[i-1] + f[i-2]を計算し、その値を f[i] に割り当てます。これにより、フィボナッチ数列の i 番目の項が計算されます。
# 最後に、配列 f の各要素を改行区切りで出力します。これは、f.each do |num| puts num endというブロックで実行されます。
# eachメソッドは、配列の各要素に対してブロックを実行し、ブロック内で num という名前の変数に現在の要素が代入されます。
# そして、puts num は num を出力し、改行します。
```

# 条件分岐メニュー
曜日の判定

```ruby
x = gets.chomp.to_i
week = ["Sat", "Sun", "Mon", "Tue", "Wed", "Thu", "Fri"]
puts week[x % 7]

# このコードは、ユーザーに整数を入力させ、それに応じた曜日を配列 week から取得して出力します。
# まず、gets.chomp.to_iで、ユーザーの入力した数を、x　として取得します。
# 次に、一週間分の曜日が入った、配列 week を用意します。
# x を7で割ったあまりの数を、配列 week のインデックスにいれて、各曜日を出力します。
```
足したり引いたり
```ruby
N, A, B = gets.split.map &:to_i

if (N + A + B == 0) || (N + A - B == 0)
    puts "YES"
elsif (N - A + B == 0) || (N - A - B == 0)
    puts "YES"
else
    puts "NO"
end

# このコードは、入力された3つの整数 N、A、B を取得し、条件に応じて "YES" または "NO" を出力するものです。
# まず、gets.split.map &:to_i により、スペースで区切られた入力を整数値の配列として取得します。
# その後、以下の条件分岐が行われます。
# N + A + B == 0 または N + A - B == 0 の場合は、"YES" を出力します。
# 上記の条件が成立しない場合で、N - A + B == 0 または N - A - B == 0 の場合は、同様に "YES" を出力します。
# それ以外の場合は、"NO" を出力します。
```

同値判定
```ruby
n = gets.to_i
arr1 = gets.chomp.split.map &:to_i 
arr2 = gets.chomp.split.map &:to_i 
num = 0

(0...n).each do |i|
    if arr1[i] == arr2[i]
        num += 1
    end
end
puts num

# このコードは、まず標準入力から整数 n を受け取ります。
# 次に、n 個の整数を含む配列aとbを受け取ります。
# そして、配列 a と b の各要素を比較し、同じ位置に同じ値がある場合にsame_countを1つ増やします。
# 最後に、same_countの値を出力します。
```

積の最小化
```ruby
a, b = gets.chomp.split.map(&:to_i)

if a <= 0 && 0 <= b
  # AからBの間に0を含む場合
  puts a * b
elsif 0 < a
  # AとB両方とも正の場合
  puts a * a
else
  # 両方とも負の場合
  puts b * b
end

# A以上B以下のうち選んだ 2 つ整数の積を最小化します。
# まずはAからBの間に 0 が含まれている場合について考えます。この場合はAが負の値、Bが正の値なので A * B が答えになります。
# AからBの間に 0 が含まれているかどうかは、a <= 0 && 0 <= bという条件式で判定できます。
# 次にA、B両方とも正の整数の場合について考えます。これはX、Y両方ともAを選ぶのが最適であることがわかります。
# よって A * A が答えになります。この場合の条件式は0 < aでよいです。
# なぜなら問題文の制約にa ≦ bが含まれているので、Aが正であるときBも正であることが保証されています。
# 最後にA、B両方とも負の整数の場合について考えます。これはX、Y両方ともBを選ぶのが最適であることがわかります。よって B * B が答えになります。
```

# ループメニュー2
各桁の和
```ruby
N = gets.chomp.to_i

digit_sum = 0
while N > 0
    digit = N % 10
    digit_sum += digit
    N /= 10
end

puts digit_sum

# このプログラムは、ユーザーから整数 N を受け取り、N の各桁の数字を取得し、それらの数字の総和を計算して出力するものです。
# 以下は、プログラムの各行の解説です。
# gets.chompメソッドを使用して、ユーザーからの入力を受け取り、文字列として変数 N に格納します。
# to_iメソッドを使用して、文字列から整数に変換します。
# digit_sum変数を 0 で初期化します。この変数は、各桁の数字の総和を格納するために使用されます。
# whileループを使用して、N の各桁の数字を取得し、digit_sum変数に加算していきます。
# N % 10を使用して、N を 10 で割った余りを取得し、それが N の一桁目の数字になります。
# 取得した数字をdigit変数に格納し、digit_sumに加算します。
# そして、N を 10 で割って、次の桁に進みます。この操作を N が 0 になるまで繰り返します。
# 最後に、計算されたdigit_sumを出力します。これは、 N の各桁の数字の総和になります。
```

# 二重ループメニュー
指定された数字までの出力

```ruby
n = gets.to_i

(1..n).each do |i|
    if i != n
        print "#{i} "
    else
        print i
    end
end

# このコードは、標準入力から数値を受け取り、 1 からその数値までの整数をスペース区切りで、【一行】で出力するものです。
# まず、gets.to_iによって標準入力から受け取った値を整数に変換し、変数 n に代入されます。
# その後、(1..n).eachによって、1 から n までの整数を順番に取り出します。取り出した整数を変数 i に代入し、次の処理を行います。
# if i != n は、もし i が n と等しくない場合に実行される条件分岐です。
# i が n と等しくない場合、print "#{i} "によって i と スペース が出力されます。
# もし i が n と等しくなる場合は、elseブロックが実行されます。print iによって、i の値が出力されます。
# 最終的に、1 から n までの整数がスペース区切りで出力されます。ただし、最後の数値の後ろにはスペースが付かないようになっています。
```

二次元配列での要素の検索

```ruby
n,k = gets.split.map &:to_i
arr = Array.new(n) {Array.new(k)}

(0...n).each do |i|
    line = gets.split.map &:to_i
    (0...k).each do |j|
        arr[i][j] = line[j]
    end    
end

(0...n).each do |i|
    (0...k).each do |j|
        if arr[i][j] == 1
            puts "#{i + 1} #{j + 1}"
        end
    end
end

# このコードは、与えられた行列の中で値が 1 である要素の行と列を表示するためのものです。
# 最初に、gets.split.map &:to_i を使用して、標準入力から n と k を受け取ります。
# それに続いて、n x k の行列を生成するために、Array.new(n) {Array.new(k)} を使用します。
# 次に、2重ループを使用して、各行と列の値を入力します。
# line = gets.split.map &:to_i を使用して、各行を読み込み、それを行列の対応する行に割り当てます。
# そして、arr[i][j] = line[j] を使用して、各列の値を行列の対応する位置に割り当てます。
# 最後に、2重ループを使用して、行列の要素を検査し、値が 1 である要素の行と列を表示します。
# if arr[i][j] == 1 を使用して、行列の要素が 1 である場合にのみ、puts "#{i + 1} #{j + 1}" を使用して、その要素の行と列を表示します。
# #{i + 1} #{j + 1} は、行列のインデックスを 1 から始めるために調整しています。
```

素数の個数
```ruby
n = gets.chomp.to_i
ans = 0

(2..n).each do |i|
    prime = true
    (2..i - 1).each do |j|
        if i % j == 0
          prime = false
          break
        end
    end
    if prime
        ans += 1
    end
end
 
puts ans

# このコードは、1 から n までの整数の中で素数の数をカウントするプログラムです。
# まず、ユーザーからの入力を受け取ります。gets.chomp.to_iで、文字列を整数に変換し、その結果を n に代入します。
# 次に、2 から n までの整数に対して、素数であるかどうかを判定します。 i が素数である場合は、ans に 1 を加算します。
# 最後に、ans の値を出力します。
# 素数であるかどうかを判定するために、2 から i-1 までの整数で、i を割り切ることができるかどうかを判定するループがあります。
# もし i を割り切ることができる整数があれば、素数でないと判定され、prime変数に false が代入されます。また、その時点で内側のループを抜けます。
# もし　i　が　2　から　i-1　までの整数で割り切ることができなければ、i　は素数であると判定され、prime変数に　true　が代入されます。
# true　の場合、if prime　の処理で、　ans に 1　を加算します。
# i が 2 の場合、内側のループ (2..i-1) は 2..1 となり、ループ自体が実行されません。prime変数は true のままなので、ans が加算されます。
```

お金の支払い
```ruby
X,Y,Z = gets.chomp.split.map(&:to_i)
ans = Z

0.upto(1500) do |i|
  0.upto(1500) do |j|
    if X*i + Y*j <= Z
      one = Z - X*i - Y*j
      if i + j + one < ans
        ans = i + j + one
      end
    end
  end
end

puts ans

# 大きな硬貨で払えるだけ払う操作を繰り返すことで最小枚数で支払うことができるように見えますが、次のような場合に正しい答えが得られません。
# 例） 1 円 , 7 円 , 16 円 を使って 21 円を支払うとき
# 大きな金額から支払った場合
# 16 円 1 枚、1 円 5 枚
# 最小枚数で支払った場合
# 7 円 3 枚
# このような場合に正しい答えを出すためにはどうしたら良いでしょうか。
# 一番楽なのは、全ての硬貨の支払い方を調べることです。全ての 1 , X , Y 円硬貨の支払い方を調べるには最大で Z^3 回ほど計算をする必要があります。
# 今回はちょうど Z 円を支払うため、X , Y 円硬貨の支払う枚数をそれぞれ a , b 枚と決めた場合、1 円硬貨を支払う枚数は Z - X × a -Y × b 枚  となります。
# また、Z < X × a + Y × b の場合は明らかに Z 円ちょうど支払うことができません。
# この関係を用いることで、支払う X , Y 円の枚数についての二重ループを用いた全探索によってこの問題を解くことができます。
# 2 ≦ X , Y ≦ 1000 と 1 ≦ Z ≦ 3000 より、X , Y 円硬貨を支払う枚数は最大で 1500 枚となるので、各ループは 0 〜 1500 で回せば良いです。
# X*i + Y*j <= Zを満たす非負の整数 i,j および one の和が最小になるような one の値を求めて出力します。
# 具体的には、ans を初期値として Z で設定し、i と j を 0 から 1500 までの範囲で2重のループで繰り返し処理を行い、
# X*i + Y*jが Z 以下の場合に one を計算し、現在の最小値 ans よりも i + j + one が小さい場合に ans を更新します。
# 最終的に、ansを出力します。

```
二重ループ：活用編 三角形の探索
```ruby
N = gets.chomp.to_i
(1...N).each do |i|
  (1...N-i).each do |j|
    k = N - i - j
    if k*k == j*j + i*i || i*i == k*k + j*j || j*j == i*i + k*k
      puts "YES"
      exit
    end
  end
end
puts "NO"

# このコードは、3つの自然数の組み合わせが三平方の定理を満たすかどうかを判断するプログラムです。
# 3 辺の長さが i,j,k である三角形が直角三角形であるとき、三平方の定理より、次のうちいずれかの条件を満たします。
# i*i = j*j + k*k
# j*j = i*i + k*k
# k*k = i*i + j*j
# よって、i , j , k について制約の範囲内で全探索することでこの三角形が直角三角形であるかどうかを三重ループで調べることができます。
# しかし、今回は制約が N ≦ 1000 であるため、 N^3 では実行時間制限に間に合わなくなってしまいます。
# そこで、 i + j + k = N という条件を利用します。
# 外側のループで、i を N まで回し、内側のループで、j　を (N-i)分回します。
# i , j の値が決まったとき、 k の値は k = N - i - j で求めることができます。
# これを利用することで、i , j の全探索の二重ループでこの問題を解くことができます。
# i, j, k の値が三平方の定理を満たす場合には、"YES"を出力してプログラムを終了します。
```

# 文字列処理メニュー
表記の訂正

```ruby
s = gets.chomp

# 小数点が複数ある場合は1つだけにする
vs = s.split('.')
if vs.length > 2
  vs1 = vs[1..-1]
  s = "#{vs[0]}.#{vs1.join('')}"
end

# 小数の場合は末尾の0を取り除く
s.gsub!(/0+$/, '') if s.include?('.')

# 先頭の0を取り除くが小数で先頭が.になってしまう場合は0を補う
s.sub!(/^0+/, '')
s = "0#{s}" if s.start_with?('.')

# s == "000" のような場合、文字列が消えてしまう。その場合は0とする
s = '0' if s.empty?

puts s

# このコードは、Rubyで入力された文字列に対して以下の処理を行っています。
# 文字列を s = gets.chomp で標準入力から受け取る。
# 次に、文字列を小数点で分割し、小数点が複数ある場合は、小数点以降を1つにまとめる。
# s = "#{vs[0]}.#{vs1.join('')}" で、小数点前と小数点以降をつなげる。
# 次に、文字列が小数である場合、正規表現で末尾に 0 が複数回あれば取り除く。
# s.gsub!(/0+$/, '') if s.include?('.')
# 続いて、文字列の先頭に 0 が複数あれば取り除く。また、小数で先頭が"."になってしまう場合は 0 を補う。
# s.sub!(/^0+/, '')
# s = "0#{s}" if s.start_with?('.')
# 最後に、文字列が空の場合は 0 とする。
```

数式の計算（ 1 桁）
```ruby
S = gets.chomp
add = true
ans = 0
(0...S.size).each do |i|
    if i % 2 == 0
        if add
            ans += S[i].to_i
        else
            ans -= S[i].to_i
        end
    else
        if S[i] == "+"
            add = true
        else
            add = false
        end
    end
end
puts ans

# このコードは、与えられた文字列 S に含まれる数値と演算子を使って、簡単な四則演算を行うものです。
# 具体的には、文字列 S を1文字ずつ処理していき、奇数番目の文字が演算子ならば、その後ろに続く数字の符号を設定し、
# 偶数番目の文字が数字ならば、符号に従って計算を行います。最終的に計算結果を ans に加算します。
# 以下、コードの各行について解説します。
# S = gets.chomp
# 標準入力から1行分の文字列を受け取り、変数 S に代入しています。chomp メソッドを使うことで、改行文字を取り除いています。
# add = true
# ans = 0
# 変数 add には、演算子の符号を表す真偽値（+ が true、- が false）を格納します。変数 ans には、計算結果を累積していきます。
# (0...S.size).each do |i|
# 0 から S.size-1 までの範囲をループ処理する each メソッドを使っています。
# ループ変数 i には、現在処理している文字のインデックスが代入されます。
# if i % 2 == 0
# 偶数番目の文字かどうかを判定しています。偶数番目の文字は、数値であることが期待されます。
# if add
#    ans += S[i].to_i
# else
#    ans -= S[i].to_i
# end
# 演算子の符号に応じて、現在処理している数値を加算または減算しています。to_i メソッドを使って、文字列を数値に変換しています。
# else
#    if S[i] == "+"
#        add = true
#    else
#        add = false
#    end
# end
# 奇数番目の文字かどうかを判定しています。奇数番目の文字は、演算子であることが期待されます。
# + の場合は add 変数に true を、- の場合は false を代入しています。
# puts ansで、最終的な計算結果を出力しています。
```

数式の計算
```ruby
S = gets.chomp
now = 0
last = S.size

(S.size - 1).downto(0) do |i|
  if S[i] == '+'
    now += S[i + 1, last - i].to_i
    last = i
  elsif S[i] == '-'
    now -= S[i + 1, last - i].to_i
    last = i
  end
end

now += S[0, last].to_i

puts now

# このコードは、与えられた文字列を解析し、その中に含まれる加算と減算の結果を計算して、最終的な合計値を出力します。
# 具体的には、以下の手順で実行されます。
# gets.chomp を使用して、標準入力から文字列 S を取得します。chomp メソッドを使用することで、改行文字を取り除くことができます。
# 変数 now を 0 に初期化します。変数 last を S の長さに設定します。
# S.size - 1 から 0 までの範囲で繰り返しを行います。これにより、文字列 S の各文字を逆順に処理できます。
# もし文字 S[i] が + であれば、次の数値を S[i+1, last-i] から桁数分取得し、整数に変換して now に加算します。
# そして、変数 last を i に設定して、次に探索する範囲を更新します。
# もし文字 S[i] が - であれば、次の数値を S[i+1, last-i] から桁数分取得し、整数に変換して now から減算します。
# そして、変数 last を i に設定して、次に探索する範囲を更新します。
# 最後に、S[0, last] から最初の数値を取得し、整数に変換して now に加算します。
# puts を使用して、変数 now の値を出力します。
# このようにして、与えられた文字列の中に含まれる加算と減算を処理し、その結果を計算して出力することができます。
```

巨大な数の足し算
```ruby
s = gets.chomp
t = gets.chomp

ans = ""
upper = 0

(s.length - 1).downto(0) do |i|
    z = s[i].to_i + t[i].to_i + upper
    upper = z / 10
    ans = (z % 10).to_s + ans
    
    if i == 0 && upper > 0
        ans = upper.to_s + ans
    end
end

puts ans

# このコードは、2つの整数 s と t を受け取り、それらを桁ごとに足し合わせて、その結果を文字列として出力するものです。
# まず、gets.chomp メソッドを使って、s と t を受け取ります。次に、空の文字列 ans と桁上げの数値 upper を初期化します。
# その後、s の末尾の桁から先頭の桁に向かって順番に処理を行います。
# 各桁で、s と t の対応する桁の数値を取得して、upper と合算し、z に代入します。
# そして、upper に z を10で割った商を代入し、余りを ans の先頭に追加します。
# 合算結果が10以上の場合は、桁上げが発生するため、upper は、1 になります。
# 合算結果が10未満の場合は、upper は、0 になり、そのまま余りを ans の先頭に追加します。
# 最後に、i が0になった時点で、桁上げが発生している場合は、その値を ans の先頭に追加し、計算結果を出力します。
```

# 配列活用メニュー
傾斜配点

```ruby
n = gets.to_i
m = gets.split.map &:to_i
ans = 0

n.times do |i|
    a = gets.split.map &:to_i
    score = 0
    5.times do |j|
        score += a[j] * m[j]
    end
    ans = score if score > ans
end

puts ans

# このコードは、入力されたデータを処理して最大スコアを見つけることを目的としています。以下にコードの各行の説明を示します。
# 1行目：n = gets.to_iは、標準入力から数値を取得し、n 変数に代入するコードです。
# 2行目：m = gets.split.map &:to_iは、標準入力から文字列を取得し、スペースで分割し、各要素を整数に変換して配列 m に代入するコードです。
# 3行目：ans = 0は、最大スコアを格納する変数 ans を初期化するコードです。
# 4行目：n.times do |i|は、n 回繰り返すループを開始するコードです。
# 5行目：a = gets.split.map &:to_iは、標準入力から文字列を取得し、スペースで分割し、各要素を整数に変換して配列 a に代入するコードです。
# 6行目：score = 0は、スコアを格納する変数 score を初期化するコードです。
# 7行目：5.times do |j|は、5回繰り返すループを開始するコードです。|j|は、timesメソッドで繰り返し中のカウンタ変数を表します。
# 8行目：score += a[j] * m[j] で２つの配列の同じインデックスの要素同士を掛け算し、スコアに加算していきます。
# a[j] と m[j] は、それぞれ a と m の配列のj番目の要素を表します。
# 9行目：ans = score if score > ans は、score が ans よりも大きい場合に ans に score を代入するコードです。
# 11行目：puts ans で、最大スコアを出力します。
```
二人三脚
```ruby
n = gets.to_i
arr = []
dif = 100
x,y = 0,0

n.times do |i|
    arr << gets.chomp.to_i
end    

arr.each_with_index do |i,num|
    arr.each_with_index do |j,num2|
        z = (i - j).abs
        if z < dif && num != num2
            dif = z
            x,y = i,j
        end
    end
end        
        
puts [x,y].sort

# このコードは、n 個の整数を入力として受け取り、それらの中で差分が最小となる2つの整数を見つけ、その2つの整数を昇順にソートして出力するものです。
# 1行目で標準入力から整数 n を取得します。
# 2行目で空の配列 arr を定義します。
# 3行目で変数 dif に初期値 100 を代入します。これは、差分の最小値を求める際に比較する値よりも十分に大きな値に設定するためです。
# 4行目で変数 x と y に初期値 0 を代入します。これらは、差分が最小となる2つの整数の値を保持するための変数です。
# 6行目で、n 回ループを実行し、標準入力から整数を受け取って配列 arr に格納します。
# 8行目から、配列 arr の要素を2つずつ取り出して、差分を計算する2重ループを each_with_index で実行します。
# 9行目で、i と j の差分の絶対値を変数 z に代入します。
# 10行目で、変数 z が現在の最小値 dif よりも小さく、かつ、i と j が同じインデックスではない場合に、最小値を更新します。
# また、最小値の更新時に、その2つの整数を変数 x と y に代入します。
# 14行目で、配列[x,y]を昇順にソートして出力します。
```

【配列に対しての複雑な処理】集団行動
```ruby
n, q = gets.chomp.split.map(&:to_i)
students = (1..n).to_a

q.times do
    s = gets.chomp.split
    if s[0] == "swap"
        a = s[1].to_i - 1
        b = s[2].to_i - 1
        tmp = students[a]
        students[a] = students[b]
        students[b] = tmp
    elsif s[0] == "reverse"
        students.reverse!
    else
        c = s[1].to_i
        if students.length > c
            students = students[0...c]
        end
    end
end

students.each do |student|
    puts student
end

# このRubyコードは、学生のリストを作成し、それを入力に基づいて操作し、最終的に学生の番号を出力するものです。
# 最初に、標準入力から2つの整数 n と q を読み取ります。n は学生の総数で、q は実行される操作の数を表します。
# 次に、1から n までの整数を含む配列を作成します。
# その後、q 回のループを行い、各ループで入力を受け取り、適切な操作を実行します。入力は、スペースで区切られた文字列で構成されています。
# 最初の文字列は操作の種類を表し、その後に操作に必要な引数が続きます。
# もし、最初の文字列が "swap" である場合は、2つの引数を読み取り、配列内の2つの要素を交換します。
# 2番目と3番目の引数を0から始まるインデックスに変換することに注意してください。
# もし、最初の文字列が "reverse" である場合は、配列を逆順にします。
# もし、最初の文字列が、それ以外の "resize" である場合は、1つの引数を変数 c として読み取ります。
# そして、配列の要素数が、c の値より大きい場合、配列を、先頭から c までの要素数に更新します。
# 最後に、最終的な学生のリストをループして、各学生の番号を出力します。
```

# クエリメニュー
指定要素の検索 (query)
```ruby
require 'set'

n, q = gets.split.map(&:to_i)
a = Set.new

n.times do
  a.add(gets.chomp.to_i)
end

q.times do
  k = gets.chomp.to_i
  if a.include?(k)
    puts "YES"
  else
    puts "NO"
  end
end

# このコードは、Setがハッシュテーブルを使用しており、キーに対してハッシュ関数を適用することにより、目的のデータの位置を直接特定できるため、処理速度が速い。
# Setを使用しない場合、要素を配列に格納するため、include?メソッドを呼び出すたびに、配列内の値を1つずつ比較する必要があります。
# したがって、要素数が増えるにつれて、処理速度が遅くなる。
# まず、require で setライブラリを読み込んでいます。set はRubyの標準ライブラリで、ハッシュセットを提供しています。
# 次に、標準入力から、スペースで区切られた整数値を取得して、n と q に代入しています。
# map(&:to_i)は、gets.splitで取得した配列の各要素に対して、to_iメソッドを呼び出して整数値に変換する処理を行っています。
# そして、a = Set.new で Setクラスのインスタンスを作成して、a に代入しています。
# a.add(gets.chomp.to_i) で、n 回ループを実行して、標準入力から整数値を取得して、Set に要素を追加しています。
# q 回ループを実行して、標準入力から整数値を取得し、Set に含まれるかどうかを判定しています。
# a.include?(k) は、Set に k が含まれるかどうかを判定するメソッドです。含まれる場合は"YES"を、含まれない場合は"NO"を出力しています。
```

先頭の要素の削除(query)
```ruby
N, K = gets.split.map(&:to_i)
A = Array.new(N) { gets.to_i }

f = 0
K.times do
  s = gets.chomp
  if s == "pop"
    f += 1
    next
  end
  A[f..-1].each {|a| puts a }
end

# このコードは、整数 N と K を入力し、N 個の整数を含むリスト A を入力して、次に K 個のコマンド（"pop"または"show"）を入力し、それに応じた処理を行うものです。
# 具体的には、"pop"が入力された場合には、リスト A の先頭から f 個の要素を取り出すことで、先頭から擬似的に削除されたことを示します。
# 一方、"show"が入力された場合には、リスト A の f 番目以降の要素をすべて出力します。f は現在削除された要素の数を示します。
# また、"pop"が入力された場合には、f の値を増やします。そして、if文の中の next で 次の A[f..-1].each {|a| puts a } の処理を飛ばします。
# このようにすることで、"show"コマンドが入力された場合のみ、リスト A の f 番目以降の要素をすべて出力することができます。
# また、このコードでは、配列をArray.new(N) { gets.to_i }のように初期化しています。
# このように初期化することで、配列の要素数を指定しつつ、要素を入力から取得することができます。
```

ソートと検索 (query) 
```ruby
N, K, P = gets.chomp.split.map(&:to_i)
A = Array.new(N) { gets.chomp.to_i }

A << P
ans = A.sort.index(P) + 1

K.times do
  event = gets.chomp

    if event == "sorting"
      puts ans
      next
    end

  x = event.split[1].to_i
  ans += 1 if x < P
end

# このコードは、 100,000回のイベント処理に耐えるため、最低限のソート回数に抑えています。
# まず、標準入力から以下のような入力を受け取ります。
# N: 配列 A の要素数。配列 A は、生徒の身長の配列。
# K: イベントの回数
# P: 前からの順番を測りたい生徒の身長。
# そして、続いて N 個の身長を入力として受け取り、配列 A に格納します。
# その後、P を A に追加し、A をソートした結果で P が何番目にあるかを計算し、変数 ans に格納します。
# ここで、P が何番目にあるかを計算するために、indexメソッドを使用しています。順番を測るため、1 を加えて ans に代入します。
# その後、K 回分のイベントを処理します。イベントは、"sorting"または"join x"の形式の文字列であり、以下のように解釈されます。
# "sorting": 配列 A をソートした結果 P が何番目にあるかを出力する
# "join x": x が P よりも低い身長の場合、ans を 1 増やす
# イベントを処理するために、K 回分の繰り返しを行い、gets.chompを使用してイベントを受け取ります。
# イベントが"sorting"の場合は、ansを出力して、次のイベントに進みます。
# そうでない場合は、"join x"の形式であることが保証されているため、x を取得し、x が P よりも小さい場合は ans を1増やします。
```
