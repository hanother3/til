【マップの扱い 2】マップの書き換え・縦横

```ruby
h, w = gets.chomp.split.map(&:to_i)
move = [-1, 1]
s = []

h.times do
  s << gets.chomp
end

y, x = gets.chomp.split.map(&:to_i)

if s[y][x] == "."
  s[y][x] = "#"
else
  s[y][x] = "."
end

move.each do |i|
  if 0 <= y + i && y + i < h
    if s[y + i][x] == "."
      s[y + i][x] = "#"
    else
      s[y + i][x] = "."
    end
  end

  if 0 <= x + i && x + i < w
    if s[y][x + i] == "."
      s[y][x + i] = "#"
    else
      s[y][x + i] = "."
    end
  end
end

s.each do |val|
  puts val
end


# このコードは、与えられた盤面に対して、指定された座標とその周囲のマスを反転させる処理を行い、変更後の盤面を出力するプログラムです。
# 最初の行では、盤面の高さを表す整数hと、盤面の幅を表す整数wを入力しています。
# getsメソッドで標準入力から取得した文字列を、splitメソッドで空白で区切って配列に分割し、mapメソッドで各要素を整数に変換して、それぞれhとwに代入しています。
# 次に、移動する量を表す配列moveを定義し、空の配列sを初期化しています。
# その後、h回ループを回しながら、getsメソッドで標準入力から取得した文字列を配列sに格納しています。
# 次に、指定された座標を表す変数yとxを、getsメソッドで標準入力から取得しています。
# その後、座標(y, x)のマスの状態によって、マスを反転させています。座標(y, x)のマスの状態が"."であれば、"#"に変更し、"#"であれば"."に変更します。
# 最後に、移動量を表す配列moveの要素を順番に取り出しながら、指定された座標から上下左右のマスを順番に反転させています。
# まず、座標(y + move[i], x)が盤面内に存在するかどうかをチェックし、存在する場合はそのマスの状態を反転させます。
# 次に、座標(y, x + move[i])が盤面内に存在するかどうかをチェックし、存在する場合はそのマスの状態を反転させます。
# 最後に、配列sの要素を順番に取り出しながら、各行を改行付きで出力しています。
```

【文字列 1】疑似数字 
```ruby
s = gets.chomp

(0...s.length).each do |i|
  (i...s.length).each do |j|
    if s[i].match?(/\d/) && s[j].match?(/\d/)
      puts s[i..j]
    end
  end
end

# このコードは、入力された文字列 s 中の数字の部分文字列を見つけて、それを出力するプログラムです。
# まず、 gets.chomp メソッドを使って、標準入力から文字列を受け取ります。受け取った文字列は、変数 s に格納されます。
# 次に、2重の each ループを使って、文字列中のすべての部分文字列の組み合わせを網羅します。
# i と j は、それぞれ部分文字列の最初の文字と最後の文字のインデックスを表します。 
# i のループ範囲は 0 から s.length - 1 までで、 j のループ範囲は i から s.length - 1 までです。
# 各部分文字列に対して、 if ステートメントを使って、文字列中の i 番目と j 番目の文字がどちらも数字である場合にのみ、その部分文字列を出力します。
# 数字であるかどうかを判断するには、 match? メソッドを使って正規表現 \d （数字）にマッチするかどうかを確認します。
# 最後に、 puts メソッドを使用して、数字の部分文字列を出力します。
# 部分文字列を取得するには、 [] メソッドによって文字列をスライスして、範囲演算子 .. を使用して、部分文字列を指定します。
# このコードでは、範囲演算子 ... を使用して、最初の値から最後の値を含まない範囲を指定することで、部分文字列の組み合わせを網羅しています。
# また、Rubyの場合、文字列の最初の文字を取得するには、0 を使う代わりに、[0] を使用することができます。

二重のeachループについて
# 外側のループが i=0 で始まり、内側のループが j=0 で始まる。
# j が増えるにつれて、s[i..j] が部分文字列になる。
# 内側のループが終了すると、外側のループが i=1 で再び始まり、内側のループが j=1 で始まる。
# これが最後の組み合わせになるまで、i と j の値を増やし続ける。

```
